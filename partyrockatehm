--// Advanced Secure Obfuscator for Roblox
function advancedObfuscate(source, VarName, WaterMark)
    warn("Started advanced secure obfuscation")

    -- Customizable variables and default values
    local Variable = VarName or "Taurus_"
    local WM = WaterMark or "WaterMark | Secure by RBLXXHEATER"

    -- Default source if none provided
    if source == nil then
        source = [[print("Hello World!")]]
    end

    -- Time measurement
    local ticks = tick()

    -- Generate watermark
    WM = "--[[".."\n".. tostring(WM) .."\n".."]]--".."\n\n"

    -- Random name generator with extended randomization
    local randomName = function(length)
        local letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        local name = ""
        for i = 1, length do
            local randChar = letters:sub(math.random(1, #letters), math.random(1, #letters))
            name = name .. randChar
        end
        return name
    end

    -- Manual string to binary converter
    local StringToBinary = function(String)
        local BinaryString = {}
        for i = 1, #String do
            local Byte = string.byte(String:sub(i, i))
            local Binary = ""
            for j = 7, 0, -1 do
                Binary = Binary .. (math.floor(Byte / 2^j) % 2)
            end
            table.insert(BinaryString, Binary)
        end
        return table.concat(BinaryString, " ")
    end

    -- Base64 encoding function
    local Base64Encode = function(data)
        local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        return ((data:gsub('.', function(x) 
            local r,b='',x:byte()
            for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end
            return r;
        end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
            if (#x < 6) then return '' end
            local c=0
            for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end
            return b:sub(c+1,c+1)
        end)..({ '', '==', '=' })[#data%3+1])
    end

    -- Multiple XOR encryption function
    local XOR = function(str, key)
        local res = {}
        for i = 1, #str do
            local xorChar = string.char(bit32.bxor(str:byte(i), key:byte((i - 1) % #key + 1)))
            table.insert(res, xorChar)
        end
        return table.concat(res)
    end

    -- Combine XOR and Base64 for stronger encryption
    local EncryptSource = function(source, key)
        local xorEncrypted = XOR(source, key)
        return Base64Encode(xorEncrypted)
    end

    -- Random binary data generator
    local add_binary = function(number, s)
        local phrases = {
            "Deobfuscate this!",
            "Good luck!",
            "GhostyDuckyy",
            "Touch some grass",
            randomName(math.random(50, 150)),
        }

        for i = 1, number do
            local randPhrase = phrases[math.random(1, #phrases)]
            local binPhrase = StringToBinary(randPhrase)
            s = s .. "local " .. Variable .. randomName(10) .. " = '" .. binPhrase .. "'; "
        end

        return s
    end

    -- Generate fake functions and variables
    local generateFakeCode = function(num)
        local fakeCode = ""
        for i = 1, num do
            local fakeVar = Variable .. randomName(math.random(8, 12))
            local fakeFunc = Variable .. randomName(math.random(8, 12))
            fakeCode = fakeCode .. "local " .. fakeVar .. " = " .. tostring(math.random()) .. "; "
            fakeCode = fakeCode .. "function " .. fakeFunc .. "() return " .. tostring(math.random(1, 1000)) .. " end; "
        end
        return fakeCode
    end

    -- Artificial delays to hinder debugging
    local function add_delay()
        for i = 1, math.random(3, 7) do
            wait(math.random(1, 3) * 0.1)  -- Random delay between 0.1 and 0.3 seconds
        end
    end

    -- Anti-tamper mechanism (script integrity check)
    local function check_integrity()
        local scriptHash = tostring(tick() * math.random(1000, 9999)):sub(1, 10)
        local currentHash = tostring(#source * math.random(1000, 9999)):sub(1, 10)
        if scriptHash ~= currentHash then
            error("Script tampering detected!")
        end
    end

    -- Encrypt the source code
    local encryptionKey = randomName(16)
    local encryptedSource = EncryptSource(source, encryptionKey)

    -- Generate fake and obfuscated code
    local SourceByte = [[local ]]..Variable..randomName(15)..[[ = {]]..encryptedSource..[[}]]
    local Loadstring = [[local ]]..Variable..randomName(15)..[[ = loadstring(table.concat({]]..EncryptSource("return function() loadstring()", encryptionKey)..[[}))()]]
    local obfuscated = WM .. Loadstring .. "; " .. add_binary(math.random(30, 50), "") .. SourceByte .. "; " .. generateFakeCode(math.random(2, 5))

    -- Add artificial delay
    add_delay()

    -- Check for tampering
    check_integrity()

    -- Copy the obfuscated code to clipboard
    setclipboard(obfuscated)

    -- Output the time taken for obfuscation
    warn("Done obfuscating in " .. tostring(tick() - ticks) .. " seconds")

    return obfuscated
end

--// Module wrapper
return function(source, CustomVarName, WaterMark)
    task.spawn(function()
        advancedObfuscate(source, CustomVarName, WaterMark)
    end)
end
